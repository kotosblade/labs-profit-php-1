<?php
/**
 * Created by PhpStorm.
 * User: kotos
 * Date: 15.08.2017
 * Time: 1:13
 */
echo '
<h1>УРОК 5. КЛАССЫ И ОБЪЕКТЫ. ВВЕДЕНИЕ В ООП.</h1>

<p>
Межем передавать заголовки, через функцию header():
<br>Пр. Перейти на страницу index.php
<br>header(\'Location: /index.php\')
</p>

<h2>КЛАСС:</h2>
<p>
<b>Класс</b> – это описание какими будут будущие объектоы (или еще можно сказать, класс - это чертеж, по котрому будут записываться объекты)
<br>
<br>Представим, что у нас есть столы. Разные. Большие и маленькие:
<br>Однако у всех этих столов есть нечто общее:
<br>- Ножки
<br>- Плоская столешница
<br>
<br>Мы можем записать, что Стол – это нечто, что обязательно имеет ножки и столешницу и обладает дополнительными свойствами: 
материал, цвет, размер, раскладывается ли (да/нет)
<br>Мы только что написали класс!
<br><br>
Как это будет выглядеть в PHP?
<br>
<textarea cols="100" rows="4">
class Table {
    public $color;
    public $legs;
}
</textarea>

<br><br>- Класс начинается с ключевого слова class
<br><br>- Название класса принято писать с большой буквы, в стиле CamelCase
<br><br>- Далее, в фигурных скобках, пишется определение класса – список его свойств и методов (функций).
<br><br>- Мы указали, что объекты класса будут иметь два публичных свойства - $color и $legs
<br><br>- Слово public обозначает, что свойство будет публичным, то есть доступным всем пользователям наших объектов
<br><br>- Указанный выше код не производит никаких активных действий! Просто определяет класс!
</p>


<h2>ОБЪЕКТЫ:</h2>
<p>
<b>Объект</b> – это экземпляр класса (те что-то - созданное по чертежу класса)
<br>
И как же создать объект?
<br>
<textarea cols="100" rows="8">
class Table {
    public $color;
    public $legs;
}
$table = new Table;
$table->color = \'black\';
$table->legs = 4;
</textarea>

<br><br>- Для создания объекта нужного нам класса применяется слово new
<br><br>- Объект – это с одной стороны, обычная переменная. Ее можно передать в функцию или использовать еще как-то.
<br><br>- С другой стороны, объект имеет свойства. Те, которые описаны в классе!
<br><br>- Доступ к свойствам мы получаем через конструкцию ->
<br><br>- Обратите внимание – знак «$» пишется только один!
</p>


<h2>МЕТОДЫ ОБЪЕКТОВ:</h2>
<p>
<b>Методы</b> – это функция. Определенная в классе. И связанная с объектами этого класса.
<br><br>
Пр. Создадим метод show():
<br>
<textarea cols="100" rows="17">
class Table {
    public $color;
    public $legs;
    
    public function show() {
        echo \'Привет, я стол!\';
        // Внутри метода мы можем обращаться к свойствами этого объекта
        // с помощью псевдопеременной $this
        echo \'О \' . $this->legs . \'ногах\';
    }
}
$table = new Table;
$table->color = \'black\';
$table->legs = 4;

// Сам же метод вызывается через ->
$table->show();
</textarea>
<br><br>

«Сбор» свойств и методов в классе называется «ИНКАПСУЛЯЦИЯ»
<br>(Когда мы собираем данные и способ работы с этими данными - заключаем в нутрь класса - это называется ИНКАПСУЛЯЦИЯ.)
</p>


<h2>ВИДИМОСТЬ (МОДИФИКАТОРЫ ВИДИМОСТИ):</h2>
<p>
<b>Модификаторы видимости</b> – дают нам возможность задать (определить), доступно ли свойство или метод «извне» или нет
<br><br>Разделение прав ВИДИМОСТи - это тоже является частью частью «ИНКАПСУЛЯЦИИ»
<b><br>ИНТЕРФЕЙС</b> - это совокупность всех публичных свойств и методов.
<br>
<br>

<b>Применение</b>
<br>Применяется, чтобы скрыть детали реализации нашего класса
<br>Скрыть промежуточные значения в объекте - непоказывая их снаружи
<br>Те с наружи должен быть красивый интерфейс с методами, а все внутренности реализации срыты.
<br>Пр.
<br>-Есть класс, в котором есть метод, при обращении к которому из вне должен возвращаться массив с данными.
<br>Данный массив получает данные из приватных свойств и методов, которые в свою очередь получают и обрабатывают данные из БД.
<br>В таком примере скрываем все методы protected и открываем только 1, как интерфейс - который будет хранить в себе весь массив
<br>

<br><b>protected</b> - ключевое слово protected вместо public приводит к тому, что обращение к свойству (или методу!) напрямую вызывает ошибку
<br>Однако «внутри», то есть в методах объекта, через $this, такое свойство/метод попрежнему доступно
<br>
Пр. 
<br>
<textarea cols="100" rows="8">
class Table {
    public $color;
    protected $legs;
}

$table = new Table;
$table->color = \'black\';
$table->legs = 4; // ОШИБКА!
</textarea>
<br>
</p>


<h2>НАСЛЕДОВАНИЕ:</h2>
<p>
<b>Наследование</b> – это передача «по наследству» свойств и методов.

<br><br>Все столы – это мебель. И стулья – тоже мебель. А еще шкафы.

<br><br>Что есть общего у всей мебели?
<br>- Материал
<br>- Размеры

<br><br>А что у каждого конкретного класса мебели?
<br>- У столов – число ножек
<br>- У стульев – мягкий или жесткий
<br>- У шкафов – количество дверей
<br><br>

Пр. Наследуем у класса Item, для класса Table:
<br>
<textarea cols="100" rows="8">
class Item {
    public $color;
    public $material;
}

class Table extends Item {
    public $legs;
}
</textarea>
<br>

<br>- Наследование реализуется указанием класса-потомка у наследника через ключевое слово <b>extends</b>.
<br>- Предок у класса может быть только один, а потомков много (т.е. нет множественного наследования).
<br>- Классы-потомки получат в наследство все свойства и методы от классов-родителей
<br>- Это значит, что нам придется писать код только один раз!

<br>
<textarea cols="100" rows="15">
class Item {
    public $color;
    
    public function showColor() {
        echo \'Мой цвет: \' . $color;
    }
}

class Table extends Item {
    public $legs;
}

$table = new Table;
$table->color = \'red\';
$table->showColor();
</textarea>
<br>

<br>- Унаследованные методы можно переписать заново в классах-потомках

<br>
<textarea cols="100" rows="17">
class Item {
    public $color;
    
    public function show() {
        echo \'Мой цвет: \' . $color;
    }
}

class Table extends Item {
    public function show() {
        echo \'Я стол. Мой цвет: \' . $color;
    }
}

$table = new Table;
$table->color = \'red\';
$table->show();
</textarea>
<br>

<br>- Если метод не переопределять, то вполне будет работать родительский.
<br>- К методу родителя можно обратиться с помощью конструкции <b>parent::method()</b>
<br><br>
</p>


<h2>КОНСТРУКТОР:</h2>
<p>
<b>КОНСТРУКТОР</b> – это «магический» метод, который выполняется АВТОМАТИЧЕСКИ при создании объекта класса.
<br>

<br>
<textarea cols="100" rows="12">
class Table extends Item {
    public function __construct($color) {
        $this->color = $color;
    }
    
    public function show() {
        echo \'Я стол. Мой цвет: \' . $color;
    }
}

$table = new Table(\'red\');
$table->show();
</textarea>
<br>

<br>- Метод-конструктор всегда называется <b>__construct</b>
<br>- Конструктор может и не иметь аргументов (как и любая другая функция!)
<br>- В конструкторе доступна переменная <b>$this</b>, как и в любом другом методе

<br>
</p>


';

