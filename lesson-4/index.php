<?php
echo '
<h1>РАБОТА С ФАЙЛАМИ</h1>

<h2>ЦИКЛ WHILE</h2>
<p>
<b>Цикл While</b> – выполняется, пока условие равно истина (true).
<br>
Если условие бесконечно, то цикл будет выполнятся не бесконечно, а определенное время, которое задано параметром в (php.ini).
<br>
(параметр вроде как называется время жизни скрипта).
<br>
<textarea cols="100" rows="9">
// while (условие) { тело цикла }
// цикл будет выполняться, ПОКА условие - ИСТИНА
$i = 1;

while ($i < 10) {
    echo $i;
    $i++; // то же, что $i = $i + 1;
}
</textarea>
<br><br>';

echo '
<h2>ЦИКЛ DO WHILE</h2>
<p>
<b>Цикл Do While</b> – в отличие от цикла While - Do While всегда выполнится хотя бы один раз.
<br>
(выполняется тело цикла, затем условие)
<br>
<textarea cols="100" rows="10">
$i = 1;

do {
    echo $i;
    $i++;
} while ($i < 10)

</textarea>
<br><br>';


echo ' 
13-00
-создадим пример с файлом

<hr>
// ЧТЕНИЕ ИЗ ФАЙЛА 1

fopen( ПУТЬКФАЙЛУ )
$res = fopen( __DIR__ . \'/db.txt\' , \'r\');
r - это еще один тип \'ресурс\'
ресурс - это соединение с чемто внешним, например с открытым файлом или БД.

$str = fgets ($res)
echo $str
File get string - прочитать содержимое файла в строчку. Те выведет первую строку в файле, если повторить, выведется 2я строка файла.

feof ($res) - возвращает true, если достигнут конец файла. И возвращает false если конец файла не достигнут.

Пр. Пока не достигнут конец файла, делай
while ( ! feof ($res)) {
    // читай строку и выводи ее содержимое в браузер.
    $str = fgets ($res);
    echo $str;
}

fclose ($res) - закрыть ресурс, после работы с ним (высвобождает память, и хороший тон)

// ЧТЕНИЕ ИЗ ФАЙЛА 2
ЧТЕНИЕ файлов – способы прочитать данные из файла в свою программу.

Всё это прекрасно, но нельзя ли как-то проще?

Конечно можно, это же PHP! 
Чтение целиком файла в массив.
$lines = file(ПУТЬКФАЙЛУ);
$res = file ( __DIR__ . \'/db.txt\' );
-результатом будет массив, где каждый элемент массива –строка.

Чтение целиком файла в строку.
$str=file_get_contents(ПУТЬКФАЙЛУ);
Самый оптимальный по производительности вариант

И еще функции, которые вам нужно знать:
readfile()
file_exists()
is_readable()
И, конечно, константа __DIR__ !

// 
fopen() отличается от include() тем, что
fopen() - прочитает и выведет содержтмое файла (содержимое файла воспринимается как набор байт, типо строковых данных)
include() - прочитает файл и добавит его содержимое к коду, как код те выполнит в нем функции итд и (те содержимое воспренимается как часть программы и все функции в нем выполняются)



// ЗАПИСЬ в файл –способы из программы записать данные в файлСпособ первый, трудоемкий, но зато всё под контролем:$res = fopen(ПУТЬКФАЙЛУ, \'w\');fwrite($res, $data); // string!fclose($res);Настала пора подробно поговорить о режимах открытия файлов:•r –чтение•r+ -чтение и запись•w–запись. файл будет создан, если не существовал или «обнулен»•w+–запись и чтение. файл будет создан, если не существовал или «обнулен»•a–запись. файл будет создан, если не существовал. запись в конец файла

// ЗАПИСЬ в файл –способы из программы записать данные в файл
Способ второй, простой, потому что это PHP:file_put_contents(ПУТЬКФАЙЛУ, $data);

................................
ЧТЕНИЕ файлов – способы прочитать данные из файла в свою программу
• Для начала нам нужно открыть файл. При этом мы получим «ресурс» – ссылку на открытый файл, с которой потом сможем работать:
$res = fopen(ПУТЬКФАЙЛУ, \'r\');
• А затем в цикле читать строки из файла:
while ( !feof($res) ) {
$line = fgets($res, 1024)
}
• И закрыть файл:
fclose($res);
• Функции, которые вам нужно знать:
• fopen()
• fclose()
• fread()
• fgets()

ЧТЕНИЕ файлов – способы прочитать данные из файла в свою программу
Всё это прекрасно, но нельзя ли как-то проще?
Конечно можно, это же PHP! 
• $lines = file(ПУТЬКФАЙЛУ);
Чтение целиком файла в массив. Каждый элемент массива – строка.
• $str = file_get_contents(ПУТЬКФАЙЛУ);
Чтение целиком файла в строку. Самый оптимальный по производительности вариант
И еще функции, которые вам нужно знать:

• readfile()
• file_exists()
• is_readable()
И, конечно, константа __DIR__ !


ЗАПИСЬ в файл – способы из программы записать данные в файл.

Способ первый, трудоемкий, но зато всё под контролем:
$res = fopen(ПУТЬКФАЙЛУ, \'w\');
fwrite($res, $data); // string!
fclose($res);

Настала пора подробно поговорить о режимах открытия файлов:
• r – чтение
• r+ - чтение и запись
• w – запись. файл будет создан, если не существовал или «обнулен»
• w+ – запись и чтение. файл будет создан, если не существовал или «обнулен»
• a – запись. файл будет создан, если не существовал. запись в конец файла
........................................................................................................................

<br>
Массивы состоят из <u>Элементов массива</u>.
<br>
Каждый <u>Элемент массива</u> состоит из <u>Индекса массива</u> и <u>Значения массива</u>.
<br>
<b>Индекс массива</b> - по нему можно обратиться к элементу. Он проставляется автоматически (в виде числа), также можно задать его в ручную в виде числа или текстового значения. 
<br>
<b>Значение массива</b> - может быть что угодно (даже массив или объект).
<br><br>

Для задания массива используются квадратные скобки
<br>
(Иногда можно встретить старый синтаксис, примерно так: array(1, 2, 3). Не используйте его!)


Массив в PHP может содержать в себе любое количество элементов любого типа:
<br>
<textarea cols="100">
$foo = [1, 13, \'bar\', \'baz\', 42]
</textarea>
<br><br>

В массив можно в любой момент добавить еще один элемент:
<br>
<textarea cols="100">
$foo = [1, 2, 3];
$foo[] = 5;
</textarea>
<br><br>

Для быстрого просмотра массива существует конструкция var_dump (вы уже знаете о ней):
<br>
<textarea cols="100">
$foo = [1, 2, 3];
var_dump($foo);
</textarea>
<br><br>
</p>






<h2>ИНДЕКСЫ МАССИВОВ</h2>
<p>
Все элементы массива, даже если это явно не указано, имеют "номер", который
называется "индекс".
<br>
Если индекс не указан, счет идет от 0.
<br>
К любому элементу можно обратиться по его индексу:
<br>
<textarea cols="100" rows="4">
$arr = [1, 2, 3];
echo $arr[0]; // 1
$arr[1] = 42;
var_dump($arr); // 1, 42, 3
</textarea>
<br><br>

Индекс можно указать явно:
<br>
<textarea cols="100">
$arr = [1 => \'январь\', 2 => \'февраль\']
</textarea>
<br><br>

Индекс может быть и числовым и строковым:
<br>
<textarea cols="100" rows="4">
$arr = [
    \'jan\' => \'январь\', \'feb\' => \'февраль\'
];
echo $arr[\'jan\']; // январь
</textarea>
<br><br>
</p>

<h2>МНОГОМЕРНЫЕ МАССИВЫ</h2>
<p>
Массив в качестве одного из своих элементов может иметь другой массив. Это так называемые многомерные массивы:
<br>
<textarea cols="100" rows="3">
$arr = [];
$arr[1] = [10, 20, 30];
$arr[2] = [100, 200, 300];
</textarea>
<br><br>

Вложенность массивов друг в друга неограничена
<br><br>

Для обращения к элементам многомерного массива используются несколько квадратных скобок:
<br>
<textarea cols="100" rows="2">
$arr[1]; // это массив [10, 20, 30]
$arr[1][0]; // это число 10
</textarea>
<br><br>

Индексы также могут быть и числовым и строковым:
<br>
<textarea cols="100" rows="1">
echo $arr[\'jan\'][1]; // понедельник
</textarea>
<br><br>
</p>

<hr>

<h1>РАБОТА С МАССИВАМИ</h1>
<h2>ЦИКЛ foreach</h2>
<p>
Специальная конструкция языка, позволяющая пройтись по всем элементам массива:
<br>
<textarea cols="100" rows="5">
$arr = [1, 2, 3];

foreach ($arr as $value) {
    echo $value;
}
</textarea>
<br><br>

Переменная <b>$value</b> на каждом шаге цикла получает значение следующего элемента массива.
<br>
Цикл закончится тогда, когда закончится обход всех элементов.
<br><br>

Можно сразу получать и индексы, в еще одну переменную:
<br>
<textarea cols="100" rows="3">
foreach ($arr as $index => $value) {
    ...
}
</textarea>
<br><br>
</p>

<h2>ФУНКЦИИ для работы с массивами</h2>
<p>
Возвращает булево значение, ответ на вопрос "есть ли в массиве такой элемент?"
<br>
<textarea cols="100" rows="1">
$res = in_array($el, $arr);
</textarea>
<br><br>

Слияние двух массивов в один, операция "объединение"
<br>
<textarea cols="100" rows="1">
$res = array_merge($a1, $a2);
</textarea>
<br><br>

Возвращает совпадающие элементы в массивах, операция "пересечение"
<br>
<textarea cols="100" rows="1">
$res = array_intersect($a1, $a2);
</textarea>
<br><br>

Превращает массив в строку, перечисляя его элементы через заданный разделитель
<br>
<textarea cols="100" rows="1">
$res = implode(\',\', $arr);
</textarea>
<br><br>

Превращает строку в массив, разбивая ее по заданному разделителю
<br>
<textarea cols="100" rows="1">
$res = explode(\',\', $str);
</textarea>
<br><br>
</p>

<hr>

<h1>ВЗАИМОДЕЙСТВИЕ С ПОЛЬЗОВАТЕЛЕМ</h1>
<h2>Метод GET протокола HTTP</h2>
<p>
Это <b>самый простой</b> метод для передачи данных от клиента на сервер. Его суть очень проста:
<br><br>
К ссылке (любой) можно прикрепить параметры и их значения:
<br>
<textarea cols="100" rows="1">
<a href="/news.php?id=12">...</a>
</textarea>
<br><br>

В данном случае имя параметра <b>"id"</b>, а значение <b>"12"</b>.
<br>
В PHP вам сразу доступны эти параметры через <b>суперглобальный массив</b> $_GET.
<br>
<textarea cols="100" rows="1">
echo $_GET[\'id\']; // 12!
</textarea>
<br><br>
Массив $_GET называется "суперглобальным" потому что доступен всегда и в любом месте вашей программы
<br><br>
Передать можно и несколько параметров сразу, разделяя их знаком "&":
<br>
<textarea cols="100" rows="1">
/news.php?topic=12&from=2016-01-01
</textarea>
<br><br>
</p>

<h2>Метод POST протокола HTTP</h2>
<p>
Это специальный метод для передачи данных от клиента на сервер.
<br><br>
В отличие от GET данные идут "невидимо" для пользователя и не отображаются в адресной строке (однако, можно посмотреть в отладчике):
<br><br>
Самое частое применение, это передача данных из формы:
<br>
<textarea cols="100" rows="4">
<form action="foo.php" method="post">
    <input type="text" name="bar">
    <input type="submit">
</form>
</textarea>
<br><br>

В этом случае в PHP данные будут доступны в массиве $_POST:
<br>
<textarea cols="100" rows="1">
echo $_POST[\'bar\'];
</textarea>
<br><br>
</p>

<h2>Суперглобальный массив $_ POST</h2>
<p>
Доступен всегда, в любом месте вашей программы.
<br><br>
Содержит в себе данные, переданные в текущем запросе от пользователя на сервер.
<br><br>
Индексы массива – совпадают с названиями полей формы.
<br><br>
Интересные особенности:
<br><br>
Точки в именах полей преобразуются в подчеркивания в индексах массива $_POST;
<br><br>
Можно передавать массивы, вот пример:
<br><br>
HTML:
<br>
<textarea cols="100" rows="2">
<input type="text" name="foo[1]">
<input type="text" name="foo[2]">
</textarea>
<br><br>
PHP:
<br>
<textarea cols="100" rows="1">
echo $_POST[\'foo\'][1];
</textarea>
<br><br>



</p>











';

?>